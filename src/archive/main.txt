/*!
** Copyright 2020 NXP
** @file main.c
** @brief
**         Main module.
**         This module contains user's application code.
*/
/*!
**  @addtogroup main_module main module documentation
**  @{
*/
/* MODULE main */


/* Including necessary configuration files. */
#include "sdk_project_config.h"
#include <string.h>
#include <stdio.h>
#include "S32K146.h"
#include "lan8651_driver.h"
//#include "SJA1124.h"
#include "pcc_hw_access.h"
#include "clock_S32K1xx.h"
#include "lan8651_driver.h"
#include "stub.h"
#define NEW_LAN_DRIVER 1


volatile int exit_code = 0;
/* User includes */


static   TC6_t * g_TC6_instance_ptr;
extern void IntHandler(uintptr_t context);

#define TIMEOUT 100000U

//Ethernet interface configuration
#define APP_IF_NAME              "eth0"
#define APP_HOST_NAME            "coap-client-demo"
#define APP_MAC_ADDR             "00-AB-CD-EF-28-60"

#define APP_USE_DHCP_CLIENT ENABLED
#define APP_IPV4_HOST_ADDR       "192.168.0.20"
#define APP_IPV4_SUBNET_MASK     "255.255.255.0"
#define APP_IPV4_DEFAULT_GATEWAY "192.168.0.254"
#define APP_IPV4_PRIMARY_DNS     "8.8.8.8"
#define APP_IPV4_SECONDARY_DNS   "8.8.4.4"

#define APP_USE_SLAAC ENABLED
#define APP_IPV6_LINK_LOCAL_ADDR "fe80::2860"
#define APP_IPV6_PREFIX          "2001:db8::"
#define APP_IPV6_PREFIX_LENGTH         64
#define APP_IPV6_GLOBAL_ADDR     "2001:db8::2860"
#define APP_IPV6_ROUTER          "fe80::1"
#define APP_IPV6_PRIMARY_DNS     "2001:4860:4860::8888"
#define APP_IPV6_SECONDARY_DNS   "2001:4860:4860::8844"

status_t stat;
void PINS_ISR(void);
void PINS_ISR(void)
{
  PINS_DRV_ClearPinIntFlagCmd(PORTD, (uint32_t) 12);
//  IntHandler(g_context);
//  TC6_HandleMacPhyInterrupt(TC6_GetInstance(context));  // context being the TC6_t * originally returned by TC6_Init()
  TC6_HandleMacPhyInterrupt((uint8_t) 0);  // context being the TC6_t * originally returned by TC6_Init()

 // TRGMUX_DRV_GenSWTrigger(INST_TRGMUX);
}

static void BSP_init(void)
{

	stat = CLOCK_DRV_Init(&clockMan1_InitConfig0);

	stat = PINS_DRV_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);

	INT_SYS_EnableIRQGlobal();
}

/*!
  \brief The main function for the project.
  \details The startup initialization sequence is the following:
 * - startup asm routine
 * - main()
*/
static TC6NoIP_t g_stub_var = {0};

int main(void)
{

	uint32_t wait,status,  count = 0;
	uint8_t masterDataSend[10];
	uint8_t masterDataReceive[10];
	char uartbuffer[100];
	unsigned char key, irbuf=0, rbuf[10], reg = 0, rw = 0;
	status_t stat;
    uint32_t         counter = 0;
    NetBuffer       net_buffer;
    size_t          offset;
    NetInterface    interface;
    NetTxAncillary *ancillary;
    uint8_t *data;

    ftm_state_t  state;

	/* Write your code here */

	BSP_init();

	PINS_DRV_WritePin(PTE, 5, 1); // CAN1_STB
	PINS_DRV_WritePin(PTE, 3, 1); // CAN2_STB

	PINS_DRV_WritePin(PTA, 9, 1); // nSleep1: Wakeup
	PINS_DRV_WritePin(PTA, 8, 0); // Brake1
	PINS_DRV_WritePin(PTE, 0, 0); // Drv1off

	PINS_DRV_WritePin(PTD, 12, 1);
	PINS_DRV_WritePin(PTD, 11, 1);

//    init_LIN_1124_Transceiver();

    //uint8_t channelnum = 0x1, id = 0x1F;
  // set_LIN_1124_ID(channelnum, id);

    // uint8_t data_frame[8] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };

    //LIN_1124_TxRxUnconditionalFrameHeader( DIR_MASTER_TX, LIN_CHAN_1 , 8,  HW_CHK_SUM_ENABLE,  data_frame);


   //	offset = (size_t) 0;  // this example buffer data is 168 bytes long - 64 byte chuck size x 3 = 192 - diff is 24




#if 0
    uint8_t buffer_data0[64] =
    { 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, \
    0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, \
    0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, \
    0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00};

    net_buffer.chunkCount       =  (uint_t) 2;
    net_buffer.maxChunkCount    =  (uint_t) 2;
    net_buffer.chunk[0].address =  buffer_data0;
    net_buffer.chunk[0].length  =  (uint16_t) 64;
    net_buffer.chunk[0].size    =  (uint16_t) 64;

    uint8_t buffer_data1[64] = {0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00 };

    net_buffer.chunk[1].address =  buffer_data1;
    net_buffer.chunk[1].length =  (uint16_t) 10;
    net_buffer.chunk[1].size =    (uint16_t) 10;


    uint8_t buffer_data0[64] =
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xAA, 0xfc, 0x70, 0x3d, 0x35, 0x26, 0x08, 0x06, 0x00, 0x01,\
    0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0xAA, 0xfc, 0x70, 0x3d, 0x35, 0x26, 0xa9, 0xfe, 0xcb, 0xab,\
	0xAA, 0x00, 0x00, 0x00, 0x00, 0x00,  0xa9, 0xfe, 0xa9, 0xfe  };
    net_buffer.chunkCount       =  (uint_t) 1;
    net_buffer.maxChunkCount    =  (uint_t) 1;
    net_buffer.chunk[0].address =  buffer_data0;
    net_buffer.chunk[0].length  =  (uint16_t) 42;
    net_buffer.chunk[0].size    =  (uint16_t) 42;
    uint8_t buffer_data1[64] = {0x77, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69 };
    net_buffer.chunkCount       =  (uint_t) 1;
    net_buffer.maxChunkCount    =  (uint_t) 1;
    net_buffer.chunk[0].address =  buffer_data0;
    net_buffer.chunk[0].length  =  (uint16_t) 64;
    net_buffer.chunk[0].size    =  (uint16_t) 64;
    uint8_t buffer_data0[64] =
       {0x10, 0xa5, 0x1d, 0x2e, 0x41, 0xc7, 0x6c, 0x29, 0xd2, 0xb0, 0x16, 0x64, 0x08, 0x00, 0x45, 0x00,\
        0x00, 0x54, 0x98, 0x1c, 0x40, 0x00, 0x3f, 0x01, 0x29, 0xa7, 0x0a, 0x40, 0x3c, 0x6a, 0x0a, 0x40, \
        0x28, 0xfc, 0x08, 0x00, 0xe5, 0xfb, 0x00, 0x0f, 0x00, 0x1d, 0xa5, 0x0e, 0xcd, 0x65, 0x00, 0x00, \
        0x00, 0x00, 0xd9, 0x90, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15};
#else
    static uint8_t buffer_data0[] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0xb3, /* ......p. */
        0xd5, 0x77, 0xf0, 0x00, 0x08, 0x00, 0x45, 0x00, /* .w.*..E. */
        0x00, 0x22, 0x37, 0x57, 0x00, 0x00, 0x80, 0x11, /* ."7W.... */
        0x00, 0x00, 0xc0, 0xa8, 0x00, 0xde, 0xc0, 0xa8, /* .F...... */
        0x00, 0xff, 0x86, 0xc9, 0x86, 0xc9, 0x00, 0x0e, /* ........ */
        0x00, 0x00, 0x01, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD  /* f....... */
    };


 #endif
#if NEW_LAN_DRIVER
	    FTM_DRV_Init(INST_FLEXTIMER_MC_1, &flexTimer_mc_1_InitConfig_0, &state);

	    /* Initialize counter */
	    FTM_DRV_InitCounter(INST_FLEXTIMER_MC_1, &flexTimer_mc_1_TimerConfig_0);

	    /* Start Counter */
	    FTM_DRV_CounterStart(INST_FLEXTIMER_MC_1);
	    bool send_once = FALSE;

#endif


#if NEW_LAN_DRIVER
     spiInit();
     g_TC6_instance_ptr = TC6_Init(&g_stub_var);
	 while (g_TC6_instance_ptr == (TC6_t * )NULL);
	 const uint8_t PLCA_node_id = 1;
	 uint8_t mac[6] =  {0x070U, 0xB3U,0xD5U, 0x77U, 0xF0U, PLCA_node_id};

	 while ( TC6Regs_Init( g_TC6_instance_ptr,  NULL,  mac, TRUE,  PLCA_node_id,  (uint8_t) 8, (uint8_t) 0, (uint8_t) 0x80,  FALSE,  FALSE,  FALSE) ==0);
	 while(!TC6Regs_GetInitDone(g_TC6_instance_ptr))
	 {
	           //  TC6_Service(TC6_Instance, true);
	  }
#else

     // interface->nicDriver = &lan8651Driver;
      interface.spiDriver = &spiDriver;
      lan8651Init(&interface);
#endif
   //  macStringToAddr(APP_MAC_ADDR, &macAddr);


   // lan8651SendPacket(&interface,  &net_buffer, offset, ancillary);
/*
    for(;;)
    {
  	masterDataSend[1] = (reg << 1) | rw;
	masterDataSend[0] = 7;  // 0b111 = normal mode
	masterDataSend[3] = 7;
	masterDataSend[2] = 0;
	LPSPI_DRV_MasterTransferBlocking(INST_LPSPI_1, (uint8_t*)&masterDataSend, (uint8_t*)&masterDataReceive, 4, TIMEOUT);
	sprintf(uartbuffer,"Response: %02X %02X %02X %02X\r\n", masterDataReceive[0]<<1,
			masterDataReceive[1]<<1 , masterDataReceive[2], masterDataReceive[3]);
	LPUART_DRV_SendData(INST_LPUART_1, (uint8_t*)uartbuffer, strlen(uartbuffer));
    }

*/


	    /* Initialize FTM */

	 for(;;)
    {
    	for (wait=0;wait<100000;wait++)
    	{ }
#if NEW_LAN_DRIVER
    	counter= 10000;

       error_t error;
      // TC6_Service(TC6_Instance, FALSE);
       TC6Regs_CheckTimers();
       TC6_HandleMacPhyInterrupt( 0 ); // this is to be deleted
       if (counter >= 10000)
       {
       	counter = 0;
       	send_once = TC6_SendRawEthernetPacket(g_TC6_instance_ptr, buffer_data0, (uint16_t) sizeof(buffer_data0), (uint8_t) 0 );

       }
#else
   lan8651SendPacket(&interface,  &net_buffer, offset, ancillary);

   status = lan8651ReadReg(&interface, LAN8651_OA_BUFSTS);

       status = status  & (uint32_t)  LAN8651_OA_BUFSTS_RCA;
       if (status >= 1  )
       {
           lan8651ReceivePacket(&interface);
       }
#endif
    }
 return exit_code;

}

/* END main */
/*!
** @}
*/
/*
   {0x6c, 0x29, 0xd2, 0xb0, 0x16, 0x64, 0x10, 0xa5, 0x1d, 0x2e, 0x41, 0xc7, 0x08, 0x00, 0x45, 0x00, \
0x00, 0x3c, 0x41, 0xb8, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x0a, 0x40, 0x28, 0xfc, 0x0a, 0x40,	\
0x28, 0x64, 0x08, 0x00, 0x48, 0x94, 0x00, 0x01, 0x04, 0xc7, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, \
0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76};


uint8_t buffer_data1[64] =
{
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, \
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, \
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, \
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};

uint8_t buffer_data2[64] = {
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, \
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, \
0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };

*/

//   ancillary->srcMacAddr = LLDP_MULTICAST_ADDR;
//   ancillary.destMacAddr = LLDP_MULTICAST_ADDR;
/* uint8_t buffer_data0[64] =
 {
 0x33, 0x33, 0x00, 0x01, 0x00, 0x02, 0x00, 0xfc, 0x70, 0x3d, 0x35, 0x26, 0x86, 0xdd, 0x60, 0x0b, \
 0x32, 0x54, 0x00, 0x72, 0xAA, 0x01, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x9f, \
 0x9d, 0xa4, 0x5e, 0xf3, 0xcc, 0x5e, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x02, 0x22, 0x02, 0x23, 0x00, 0x72, 0x14, 0xd2, 0x01, 0x24};

 uint8_t buffer_data1[64] =
 {
 0x72, 0x72, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x01, \
 0x2a, 0x2a, 0x99, 0x94, 0x08, 0x92, 0x04, 0x6e, 0xa3, 0x99, 0x00, 0x03, 0x00, 0x0c, 0x34, 0x00, \
 0xfc, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x1c, 0x00, 0x0c, \
 0x54, 0x52, 0x59, 0x4e, 0x42, 0x4a, 0x44, 0x44, 0x47, 0x4e, 0x4e, 0x33, 0x05, 0x6d, 0x61, 0x67};

 uint8_t buffer_data2[64] = {
 0x6e, 0x61, 0x06, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x00, 0x00, 0x10, 0x00, 0x0e, 0x00, 0x00, \
 0x01, 0x37, 0x00, 0x08, 0x4d, 0x53, 0x46, 0x54, 0x20, 0x35, 0x2e, 0x30, 0x00, 0x06, 0x00, 0x08, \
 0x00, 0x11, 0x00, 0x17, 0x00, 0x18, 0x00, 0x27 };

 net_buffer.chunkCount = (uint_t) 3;
 net_buffer.maxChunkCount = (uint_t) 1;
 net_buffer.chunk[0].address = buffer_data0;
 net_buffer.chunk[0].length = (uint16_t) 64;
 net_buffer.chunk[0].size = (uint16_t) 64;
 net_buffer.chunk[1].address = buffer_data1;
 net_buffer.chunk[1].length = (uint16_t) 64;
 net_buffer.chunk[1].size = (uint16_t) 64;
 net_buffer.chunk[2].address = buffer_data2;
 net_buffer.chunk[2].length = (uint16_t) 40;
 net_buffer.chunk[2].size = (uint16_t) 40;



 uint8_t buffer_data1[64] =
{0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, \
 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, \
 0x36, 0x37};
 */
